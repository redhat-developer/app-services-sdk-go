// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package kafkainstanceclient

import (
	_context "context"
	_nethttp "net/http"
	"sync"
)

// Ensure, that RecordsApiMock does implement RecordsApi.
// If this is not the case, regenerate this file with moq.
var _ RecordsApi = &RecordsApiMock{}

// RecordsApiMock is a mock implementation of RecordsApi.
//
// 	func TestSomethingThatUsesRecordsApi(t *testing.T) {
//
// 		// make and configure a mocked RecordsApi
// 		mockedRecordsApi := &RecordsApiMock{
// 			ConsumeRecordsFunc: func(ctx _context.Context, topicName string) ApiConsumeRecordsRequest {
// 				panic("mock out the ConsumeRecords method")
// 			},
// 			ConsumeRecordsExecuteFunc: func(r ApiConsumeRecordsRequest) (RecordList, *_nethttp.Response, error) {
// 				panic("mock out the ConsumeRecordsExecute method")
// 			},
// 			ProduceRecordFunc: func(ctx _context.Context, topicName string) ApiProduceRecordRequest {
// 				panic("mock out the ProduceRecord method")
// 			},
// 			ProduceRecordExecuteFunc: func(r ApiProduceRecordRequest) (Record, *_nethttp.Response, error) {
// 				panic("mock out the ProduceRecordExecute method")
// 			},
// 		}
//
// 		// use mockedRecordsApi in code that requires RecordsApi
// 		// and then make assertions.
//
// 	}
type RecordsApiMock struct {
	// ConsumeRecordsFunc mocks the ConsumeRecords method.
	ConsumeRecordsFunc func(ctx _context.Context, topicName string) ApiConsumeRecordsRequest

	// ConsumeRecordsExecuteFunc mocks the ConsumeRecordsExecute method.
	ConsumeRecordsExecuteFunc func(r ApiConsumeRecordsRequest) (RecordList, *_nethttp.Response, error)

	// ProduceRecordFunc mocks the ProduceRecord method.
	ProduceRecordFunc func(ctx _context.Context, topicName string) ApiProduceRecordRequest

	// ProduceRecordExecuteFunc mocks the ProduceRecordExecute method.
	ProduceRecordExecuteFunc func(r ApiProduceRecordRequest) (Record, *_nethttp.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// ConsumeRecords holds details about calls to the ConsumeRecords method.
		ConsumeRecords []struct {
			// Ctx is the ctx argument value.
			Ctx _context.Context
			// TopicName is the topicName argument value.
			TopicName string
		}
		// ConsumeRecordsExecute holds details about calls to the ConsumeRecordsExecute method.
		ConsumeRecordsExecute []struct {
			// R is the r argument value.
			R ApiConsumeRecordsRequest
		}
		// ProduceRecord holds details about calls to the ProduceRecord method.
		ProduceRecord []struct {
			// Ctx is the ctx argument value.
			Ctx _context.Context
			// TopicName is the topicName argument value.
			TopicName string
		}
		// ProduceRecordExecute holds details about calls to the ProduceRecordExecute method.
		ProduceRecordExecute []struct {
			// R is the r argument value.
			R ApiProduceRecordRequest
		}
	}
	lockConsumeRecords        sync.RWMutex
	lockConsumeRecordsExecute sync.RWMutex
	lockProduceRecord         sync.RWMutex
	lockProduceRecordExecute  sync.RWMutex
}

// ConsumeRecords calls ConsumeRecordsFunc.
func (mock *RecordsApiMock) ConsumeRecords(ctx _context.Context, topicName string) ApiConsumeRecordsRequest {
	if mock.ConsumeRecordsFunc == nil {
		panic("RecordsApiMock.ConsumeRecordsFunc: method is nil but RecordsApi.ConsumeRecords was just called")
	}
	callInfo := struct {
		Ctx       _context.Context
		TopicName string
	}{
		Ctx:       ctx,
		TopicName: topicName,
	}
	mock.lockConsumeRecords.Lock()
	mock.calls.ConsumeRecords = append(mock.calls.ConsumeRecords, callInfo)
	mock.lockConsumeRecords.Unlock()
	return mock.ConsumeRecordsFunc(ctx, topicName)
}

// ConsumeRecordsCalls gets all the calls that were made to ConsumeRecords.
// Check the length with:
//     len(mockedRecordsApi.ConsumeRecordsCalls())
func (mock *RecordsApiMock) ConsumeRecordsCalls() []struct {
	Ctx       _context.Context
	TopicName string
} {
	var calls []struct {
		Ctx       _context.Context
		TopicName string
	}
	mock.lockConsumeRecords.RLock()
	calls = mock.calls.ConsumeRecords
	mock.lockConsumeRecords.RUnlock()
	return calls
}

// ConsumeRecordsExecute calls ConsumeRecordsExecuteFunc.
func (mock *RecordsApiMock) ConsumeRecordsExecute(r ApiConsumeRecordsRequest) (RecordList, *_nethttp.Response, error) {
	if mock.ConsumeRecordsExecuteFunc == nil {
		panic("RecordsApiMock.ConsumeRecordsExecuteFunc: method is nil but RecordsApi.ConsumeRecordsExecute was just called")
	}
	callInfo := struct {
		R ApiConsumeRecordsRequest
	}{
		R: r,
	}
	mock.lockConsumeRecordsExecute.Lock()
	mock.calls.ConsumeRecordsExecute = append(mock.calls.ConsumeRecordsExecute, callInfo)
	mock.lockConsumeRecordsExecute.Unlock()
	return mock.ConsumeRecordsExecuteFunc(r)
}

// ConsumeRecordsExecuteCalls gets all the calls that were made to ConsumeRecordsExecute.
// Check the length with:
//     len(mockedRecordsApi.ConsumeRecordsExecuteCalls())
func (mock *RecordsApiMock) ConsumeRecordsExecuteCalls() []struct {
	R ApiConsumeRecordsRequest
} {
	var calls []struct {
		R ApiConsumeRecordsRequest
	}
	mock.lockConsumeRecordsExecute.RLock()
	calls = mock.calls.ConsumeRecordsExecute
	mock.lockConsumeRecordsExecute.RUnlock()
	return calls
}

// ProduceRecord calls ProduceRecordFunc.
func (mock *RecordsApiMock) ProduceRecord(ctx _context.Context, topicName string) ApiProduceRecordRequest {
	if mock.ProduceRecordFunc == nil {
		panic("RecordsApiMock.ProduceRecordFunc: method is nil but RecordsApi.ProduceRecord was just called")
	}
	callInfo := struct {
		Ctx       _context.Context
		TopicName string
	}{
		Ctx:       ctx,
		TopicName: topicName,
	}
	mock.lockProduceRecord.Lock()
	mock.calls.ProduceRecord = append(mock.calls.ProduceRecord, callInfo)
	mock.lockProduceRecord.Unlock()
	return mock.ProduceRecordFunc(ctx, topicName)
}

// ProduceRecordCalls gets all the calls that were made to ProduceRecord.
// Check the length with:
//     len(mockedRecordsApi.ProduceRecordCalls())
func (mock *RecordsApiMock) ProduceRecordCalls() []struct {
	Ctx       _context.Context
	TopicName string
} {
	var calls []struct {
		Ctx       _context.Context
		TopicName string
	}
	mock.lockProduceRecord.RLock()
	calls = mock.calls.ProduceRecord
	mock.lockProduceRecord.RUnlock()
	return calls
}

// ProduceRecordExecute calls ProduceRecordExecuteFunc.
func (mock *RecordsApiMock) ProduceRecordExecute(r ApiProduceRecordRequest) (Record, *_nethttp.Response, error) {
	if mock.ProduceRecordExecuteFunc == nil {
		panic("RecordsApiMock.ProduceRecordExecuteFunc: method is nil but RecordsApi.ProduceRecordExecute was just called")
	}
	callInfo := struct {
		R ApiProduceRecordRequest
	}{
		R: r,
	}
	mock.lockProduceRecordExecute.Lock()
	mock.calls.ProduceRecordExecute = append(mock.calls.ProduceRecordExecute, callInfo)
	mock.lockProduceRecordExecute.Unlock()
	return mock.ProduceRecordExecuteFunc(r)
}

// ProduceRecordExecuteCalls gets all the calls that were made to ProduceRecordExecute.
// Check the length with:
//     len(mockedRecordsApi.ProduceRecordExecuteCalls())
func (mock *RecordsApiMock) ProduceRecordExecuteCalls() []struct {
	R ApiProduceRecordRequest
} {
	var calls []struct {
		R ApiProduceRecordRequest
	}
	mock.lockProduceRecordExecute.RLock()
	calls = mock.calls.ProduceRecordExecute
	mock.lockProduceRecordExecute.RUnlock()
	return calls
}
