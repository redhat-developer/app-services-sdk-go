// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package smarteventsclient

import (
	_context "context"
	_nethttp "net/http"
	"sync"
)

// Ensure, that ErrorCatalogApiMock does implement ErrorCatalogApi.
// If this is not the case, regenerate this file with moq.
var _ ErrorCatalogApi = &ErrorCatalogApiMock{}

// ErrorCatalogApiMock is a mock implementation of ErrorCatalogApi.
//
// 	func TestSomethingThatUsesErrorCatalogApi(t *testing.T) {
//
// 		// make and configure a mocked ErrorCatalogApi
// 		mockedErrorCatalogApi := &ErrorCatalogApiMock{
// 			ErrorsAPIGetErrorFunc: func(ctx _context.Context, id int32) ApiErrorsAPIGetErrorRequest {
// 				panic("mock out the ErrorsAPIGetError method")
// 			},
// 			ErrorsAPIGetErrorExecuteFunc: func(r ApiErrorsAPIGetErrorRequest) (BridgeError, *_nethttp.Response, error) {
// 				panic("mock out the ErrorsAPIGetErrorExecute method")
// 			},
// 			ErrorsAPIGetErrorsFunc: func(ctx _context.Context) ApiErrorsAPIGetErrorsRequest {
// 				panic("mock out the ErrorsAPIGetErrors method")
// 			},
// 			ErrorsAPIGetErrorsExecuteFunc: func(r ApiErrorsAPIGetErrorsRequest) (ErrorListResponse, *_nethttp.Response, error) {
// 				panic("mock out the ErrorsAPIGetErrorsExecute method")
// 			},
// 		}
//
// 		// use mockedErrorCatalogApi in code that requires ErrorCatalogApi
// 		// and then make assertions.
//
// 	}
type ErrorCatalogApiMock struct {
	// ErrorsAPIGetErrorFunc mocks the ErrorsAPIGetError method.
	ErrorsAPIGetErrorFunc func(ctx _context.Context, id int32) ApiErrorsAPIGetErrorRequest

	// ErrorsAPIGetErrorExecuteFunc mocks the ErrorsAPIGetErrorExecute method.
	ErrorsAPIGetErrorExecuteFunc func(r ApiErrorsAPIGetErrorRequest) (BridgeError, *_nethttp.Response, error)

	// ErrorsAPIGetErrorsFunc mocks the ErrorsAPIGetErrors method.
	ErrorsAPIGetErrorsFunc func(ctx _context.Context) ApiErrorsAPIGetErrorsRequest

	// ErrorsAPIGetErrorsExecuteFunc mocks the ErrorsAPIGetErrorsExecute method.
	ErrorsAPIGetErrorsExecuteFunc func(r ApiErrorsAPIGetErrorsRequest) (ErrorListResponse, *_nethttp.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// ErrorsAPIGetError holds details about calls to the ErrorsAPIGetError method.
		ErrorsAPIGetError []struct {
			// Ctx is the ctx argument value.
			Ctx _context.Context
			// ID is the id argument value.
			ID int32
		}
		// ErrorsAPIGetErrorExecute holds details about calls to the ErrorsAPIGetErrorExecute method.
		ErrorsAPIGetErrorExecute []struct {
			// R is the r argument value.
			R ApiErrorsAPIGetErrorRequest
		}
		// ErrorsAPIGetErrors holds details about calls to the ErrorsAPIGetErrors method.
		ErrorsAPIGetErrors []struct {
			// Ctx is the ctx argument value.
			Ctx _context.Context
		}
		// ErrorsAPIGetErrorsExecute holds details about calls to the ErrorsAPIGetErrorsExecute method.
		ErrorsAPIGetErrorsExecute []struct {
			// R is the r argument value.
			R ApiErrorsAPIGetErrorsRequest
		}
	}
	lockErrorsAPIGetError         sync.RWMutex
	lockErrorsAPIGetErrorExecute  sync.RWMutex
	lockErrorsAPIGetErrors        sync.RWMutex
	lockErrorsAPIGetErrorsExecute sync.RWMutex
}

// ErrorsAPIGetError calls ErrorsAPIGetErrorFunc.
func (mock *ErrorCatalogApiMock) ErrorsAPIGetError(ctx _context.Context, id int32) ApiErrorsAPIGetErrorRequest {
	if mock.ErrorsAPIGetErrorFunc == nil {
		panic("ErrorCatalogApiMock.ErrorsAPIGetErrorFunc: method is nil but ErrorCatalogApi.ErrorsAPIGetError was just called")
	}
	callInfo := struct {
		Ctx _context.Context
		ID  int32
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockErrorsAPIGetError.Lock()
	mock.calls.ErrorsAPIGetError = append(mock.calls.ErrorsAPIGetError, callInfo)
	mock.lockErrorsAPIGetError.Unlock()
	return mock.ErrorsAPIGetErrorFunc(ctx, id)
}

// ErrorsAPIGetErrorCalls gets all the calls that were made to ErrorsAPIGetError.
// Check the length with:
//     len(mockedErrorCatalogApi.ErrorsAPIGetErrorCalls())
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorCalls() []struct {
	Ctx _context.Context
	ID  int32
} {
	var calls []struct {
		Ctx _context.Context
		ID  int32
	}
	mock.lockErrorsAPIGetError.RLock()
	calls = mock.calls.ErrorsAPIGetError
	mock.lockErrorsAPIGetError.RUnlock()
	return calls
}

// ErrorsAPIGetErrorExecute calls ErrorsAPIGetErrorExecuteFunc.
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorExecute(r ApiErrorsAPIGetErrorRequest) (BridgeError, *_nethttp.Response, error) {
	if mock.ErrorsAPIGetErrorExecuteFunc == nil {
		panic("ErrorCatalogApiMock.ErrorsAPIGetErrorExecuteFunc: method is nil but ErrorCatalogApi.ErrorsAPIGetErrorExecute was just called")
	}
	callInfo := struct {
		R ApiErrorsAPIGetErrorRequest
	}{
		R: r,
	}
	mock.lockErrorsAPIGetErrorExecute.Lock()
	mock.calls.ErrorsAPIGetErrorExecute = append(mock.calls.ErrorsAPIGetErrorExecute, callInfo)
	mock.lockErrorsAPIGetErrorExecute.Unlock()
	return mock.ErrorsAPIGetErrorExecuteFunc(r)
}

// ErrorsAPIGetErrorExecuteCalls gets all the calls that were made to ErrorsAPIGetErrorExecute.
// Check the length with:
//     len(mockedErrorCatalogApi.ErrorsAPIGetErrorExecuteCalls())
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorExecuteCalls() []struct {
	R ApiErrorsAPIGetErrorRequest
} {
	var calls []struct {
		R ApiErrorsAPIGetErrorRequest
	}
	mock.lockErrorsAPIGetErrorExecute.RLock()
	calls = mock.calls.ErrorsAPIGetErrorExecute
	mock.lockErrorsAPIGetErrorExecute.RUnlock()
	return calls
}

// ErrorsAPIGetErrors calls ErrorsAPIGetErrorsFunc.
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrors(ctx _context.Context) ApiErrorsAPIGetErrorsRequest {
	if mock.ErrorsAPIGetErrorsFunc == nil {
		panic("ErrorCatalogApiMock.ErrorsAPIGetErrorsFunc: method is nil but ErrorCatalogApi.ErrorsAPIGetErrors was just called")
	}
	callInfo := struct {
		Ctx _context.Context
	}{
		Ctx: ctx,
	}
	mock.lockErrorsAPIGetErrors.Lock()
	mock.calls.ErrorsAPIGetErrors = append(mock.calls.ErrorsAPIGetErrors, callInfo)
	mock.lockErrorsAPIGetErrors.Unlock()
	return mock.ErrorsAPIGetErrorsFunc(ctx)
}

// ErrorsAPIGetErrorsCalls gets all the calls that were made to ErrorsAPIGetErrors.
// Check the length with:
//     len(mockedErrorCatalogApi.ErrorsAPIGetErrorsCalls())
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorsCalls() []struct {
	Ctx _context.Context
} {
	var calls []struct {
		Ctx _context.Context
	}
	mock.lockErrorsAPIGetErrors.RLock()
	calls = mock.calls.ErrorsAPIGetErrors
	mock.lockErrorsAPIGetErrors.RUnlock()
	return calls
}

// ErrorsAPIGetErrorsExecute calls ErrorsAPIGetErrorsExecuteFunc.
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorsExecute(r ApiErrorsAPIGetErrorsRequest) (ErrorListResponse, *_nethttp.Response, error) {
	if mock.ErrorsAPIGetErrorsExecuteFunc == nil {
		panic("ErrorCatalogApiMock.ErrorsAPIGetErrorsExecuteFunc: method is nil but ErrorCatalogApi.ErrorsAPIGetErrorsExecute was just called")
	}
	callInfo := struct {
		R ApiErrorsAPIGetErrorsRequest
	}{
		R: r,
	}
	mock.lockErrorsAPIGetErrorsExecute.Lock()
	mock.calls.ErrorsAPIGetErrorsExecute = append(mock.calls.ErrorsAPIGetErrorsExecute, callInfo)
	mock.lockErrorsAPIGetErrorsExecute.Unlock()
	return mock.ErrorsAPIGetErrorsExecuteFunc(r)
}

// ErrorsAPIGetErrorsExecuteCalls gets all the calls that were made to ErrorsAPIGetErrorsExecute.
// Check the length with:
//     len(mockedErrorCatalogApi.ErrorsAPIGetErrorsExecuteCalls())
func (mock *ErrorCatalogApiMock) ErrorsAPIGetErrorsExecuteCalls() []struct {
	R ApiErrorsAPIGetErrorsRequest
} {
	var calls []struct {
		R ApiErrorsAPIGetErrorsRequest
	}
	mock.lockErrorsAPIGetErrorsExecute.RLock()
	calls = mock.calls.ErrorsAPIGetErrorsExecute
	mock.lockErrorsAPIGetErrorsExecute.RUnlock()
	return calls
}
